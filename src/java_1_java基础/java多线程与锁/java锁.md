## Java 锁分类

![导图1](https://i.loli.net/2020/10/24/1mnIWzliAFjD9Qu.png)





# JVM 锁优化

## 锁消除

**锁消除是在编译器级别的事情**。虚拟机即时编译器在运行时，如果发现不可能存在共享数据竞争的锁，则可以消除这些对象的锁操作。

## 锁粗化

原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。

**锁粗化就是增大锁的作用域,减少锁定的次数。**

# JVM 锁状态

## **锁的四种状态**

**锁主要存在四中状态，依次是：**

- **无锁状态**

- **偏向锁状态**

- **轻量级锁状态**

- **重量级锁状态**

## 轻量级锁

引入轻量级锁的主要目的是在**没有多线程竞争**的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

> 当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：

**获取锁**

- **无锁状态**

- 在线程私有栈帧 中建立 锁记录存储 **markWord**拷贝
- 利用 CAS 操作尝试将对象的 MarkWord 更新为指向 LockRecord 的 指针,成功 表示竞争到锁

## 偏向锁

### **比较标识**

比较 **是否为偏向锁** , **偏向锁所偏向的线程 id**

### **偏向锁竞争**

**CAS 竞争成功**

如果当前锁 偏向的线程 Id, 不为当前线程的 id, 则通过 CAS 竞争锁 竞争成功,则将线程 id 替换为当前线程 id,然后执行同步代码

**CAS 竞争失败**

CAS 竞争锁失败,证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；

### 偏向锁释放

**只有竞争才会释放锁**

> 线程是不会主动去释放偏向锁，需要等待其他线程来竞争。 偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。

## 自旋锁与自适应自旋锁

- 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多
- 反之,如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。

**自旋与非自旋**

![自旋与非自旋](https://i.loli.net/2020/10/24/dUJvRxQXbhiOAuz.png)







# JVM锁实现

## **synchronized**的实现

每个锁关联一个线程持有者和一个计数器

* 当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁
* 当一个线程请求成功后，JVM会记下持有锁的线程id，并将计数器计为1
* 此时其他线程请求该锁，则必须等待。
* 而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增

故 **synchronized** 是可重入锁

java线程是基于“每线程（per-thread）”，而不是基于“每调用（per-invocation）”的





[参考](https://www.toutiao.com/i6884966680137728526/)





