# C++对 C 的加强

## 变量与常量

* register 关键字在 C++中失效了,只是为了兼容C语言

* C 语言可以同时声明多个同名变量,指向同一个地址空间,C++编译不通过

* C 语言中的 const 关键字只是在编译器限制 变量不可变

    ①C++对于 const 作了加强,当碰见常量声明时,在符号表中放入常量,编译过程中若发现使用常量则直接以符号表中的值替换

    ②C++编译器不一定给常量分配空间,  只有对 const 使用了 extern 或者&操作符, 时才会分配空间但是不会使用这个存储空间的值 

    ③C++ 常量跟宏的区别, 作用域的区别

**宏的作用域 是整个文件**,这样会导致权限无法限定, (可以通过 undefined 来限定) 

```c++
#define a 3
#undefine a
```

## `struct` 为新类型

* C++的类型: struct 类型

* C 语言的 struct 类型 ,编译器认为只是变量的集合, 而不是新类型, C++是新类型

```c++
struct Student{
	const char * name;
	int age;
}
//C++
int main(){
	Student s1 = {"sdff",30};
	Student s2 = {"sdff",31};
}
//C
{
    struct Student s1 = {};
}
```



## 函数默认参数与默认返回值

* C 语言中的默认类型 f(i); 
* 默认为整数参数,返回值默认为整数
* 在 C++中不支持



## c++bool类型

* C++中的 bool 类型 取值 是 `true` `false` ,

* 理论上只占用 一个字节,如果多个 bool 类型定义在一起,*可能会被放到 同一个字节中(依据编译器的不同)* 
*  给 C++中的 bool 类型赋值 整数时,非 0 为 true,0 为 false,(兼容C语言)

## C++中的三目运算符

* 可以作为左值使用

    三目运算符的返回值 如果返回的时一个变量,则可以当做左值使用,如果可能的返回值里面有一个是常量,则不能作为左值使用





## C++中的引用

**变量**

* `变量` 一段连续内存空间的别名
* 程序通过变量来申请存储空间
* 通过变量可以使用存储空间

**引用 **

**是已经定义变量的别名**(`引用 必须用其他的变量初始化`)

1. 语法 Type& name=varname;
2. 引用 可读性 好
3. 引用作为函数参数
4. const int &a 引用,const 引用只是让变量 拥有只读属性
5. const 引用进行初始化 时,C++编译器会为常量值 分配空间,并将引用名作为这段空间的别名, 跟 C 语言中的 只读变量一样
6. 引用有自己的空间吗? 引用的 本质上是 C 语言中的 常指针 Type & name -> Type \* const name 为了实用性,而做出的细节隐藏
7. 引用作为函数返回值 时 不能 作为左值使用, 当引用是静态全局变量时 可以
8. 无法建立引用数组



## 内联函数

1. 内联函数 必须与函数定义结合在一起

   1. `inline int func(int a){return a<b?:a:b;}` 直接 对其他调用它的函数 进行 直接 插入替换

   2. C++不一定响应函数的内联 请求,如果 请求不通过,则 退化成普通函数,

   3. 内联函数没有普通函数 调用的开销,编译器还是会进行类型检查

   4. 宏是由 预处理器进行简单的替换的,而 内联函数 是 由编译器进行的

   5. 强制 内联编译 inline int func(int a) **attribute\_((always_inline)); g++ -S 编译成汇编代码 **

   6. C++内联 编译的 限制 :

      1. 不能存在任何形式的循环语句

      2. 不能存在过多的条件判断

      3. 函数体不能过于庞大,一般比超过五句

      4. 不能对函数进行取址操作

      5. 函数内联声明必须在调用语句之前

2. C++中的 符号表 ,是 C++编译器 在编译代码 时 自己使用的 在处理内联请求 时,会把 内联函数放到 符号表中,当有地方调用它时,会进行类型检查,返回值检查

3. 函数默认参数

    1. int mul(x=0); 函数参数默认值
    2. 一旦函数参数开始使用 默认值,其后的参数必须也使用默认值

4. C++的函数占位参数,

    1. `int func(int a,int b,int)` 无法使用函数占位参数
    2. `int func(int a,int b,int=0)`

5. C++中的重载

    1. 函数名相同,定义不同的函数参数
    2. 函数重载,跟默认参数 会发生二义性, 编译不通过
    3. 函数重载的编译方法精确匹配实参, 默认参数匹配, 默认类型转发匹配,同时进行,不能存在二义性
    4. 函数重载 与函数指针 在用函数名称 跟函数指针 赋值时 选择与函数指针类型参数列表篇一致 的候选者

6. C,与 C++的相互调用

    1. C 语言的编译器 兼容 C 语言的编译器

    2. C++ 优先使用 C++的编译方式, extern 强制让 C++对代码进行 C 方式编译

    3. `extern "C"{ #include "add.h" }` 告诉 g++ 编译器, 这个头文件里的文件都是 C 语言编译的

    4. 内置宏

       ```c++
       #ifdef  __cplusplus
       extern "C"{       #endif      #ifdef __cplusplus       }
       #endif
       ```

    5. C++ 编译器不能以 C 的方式 编译重载

7. 动态内存申请:(新增)

    1. 变量 Type \* pointe=new Type;
    2. 数组申请 Type \* pointer =new Type[N];
    3. delete pointer 释放内存,delete [ ] pointer
    4. int \* pi=new int(1) 申请空间时初始化,内存空间

8. C++在中的命名空间

    1. C 语言中所有的全局标识符共享同一个作用域,标识符之间可能会发生冲突

    2. 命名空间将全局作用域分成不同的部分,不同命名空间中的标识符,可以重名,命名空间可以相互嵌套,全局作用域 也叫默认命名空间

    3. 命名空间的定义

       ```c++
       namespace first{       int i=0;     }
       namespace second{       int i=0;
                        namespace Internal{       int p=0;
       }}
       ```

    4. 命名空间的使用

       ```c++
       using namespace First; //可以直接使用命名空间的所有定义变量
       using Second::Internal::P;     //Second::i 使用second命名空间中的i
       ```

9. 强制类型转换

    ① 基本类型转换 `static_cast`

    ```
    char c=static_cast<char)(i);
    char *c=static_cast<char *)(i);  //错误 ,只能用于基本类型的转换,只是在编译器检查
    ```

    ②const_cast 去除变量的 const 属性

    ```c++
    const int &j=1;
    int &k=const_cast<int &>(j);
    const int x=2;
    int &y= const_cast<int&>(x) //这会发生x,y 地址相同,但是值不同
    ```

    ③reinterpret_cast 指针类型转换 和 整数跟指针类型间的强制转换

    直接从二进制位进行复制,是一种及其不安全的转换

    ④volatile const int y=2 退化成只读变量, const int z = y 将变量赋值给 一个常量 会退化成 只读变量

    ⑤ 凡是不能在编译器确定的 常量,均退化成只读变量,

    ⑥ 常(只读)引用,在用相同类型初始化时,会引用 相同的变量, 如果 用不同类型的初始化时,会生成一个新的只读变量

10. 操作引用就是操作变量本身

11. extern C 告诉 C++ 编译器 以 C 语言的方式编译 但只是以 C 语言的函数命名方式 编译的,函数体还是 按 C++的方式编译, c++为了重载,函数名经过编译之后 会加上参数信息,因而编译后的函数名与源码中不同 C 语言的编译方式不允许函数重载
