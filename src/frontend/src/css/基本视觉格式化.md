## Basic Boxes

1. **CSS 的核心是假设每个元素都生成一个或多个矩形框，称为元素框**。（该规范的未来版本可能允许使用非矩形框，并且确实有人提议更改此内容，但目前所有内容都是矩形的)

2. 每个元素框的中心都有一个内容区。

3. 此内容区域由可选数量的padding（填充）、borders（边框）、outlines（轮廓）和外边距（margins）包围。
4. 这些区域是可选的，因为它们都可以设置为零的宽度，从而将它们从元素框中删除。

5.  *margins*, *borders*,  *padding* 可以使用 特定于 某一边的 属性设置值 例如 *margin-left* *border-bottom*
6. *outline*没有 特定于某一边的 属性
7. 默认情况下，内容的背景（例如彩色或平铺图像）包含 *padding*部分
8. *margins* 始终是 透明的 ，以使得 父元素的背景可见
9. *padding* 不能有负长度，*margins* 可以
10. *border* 
    1. 需要定义 颜色 跟 宽度。
    2. 如果没有定义颜色 则取元素的前景色作为颜色，
    3. 如果边框有某种间隙的样式，则默认在 间隙之间会 显示 元素的背景色
    4. 边框的宽度不能为负值





## A Quick Refresher 

Let’s quickly review the kinds of boxes we’ll be discussing, 

让我们快速回顾一下我们将要讨论的盒子种类，以及一些需要解释的重要术语

### Normal flow

这是西方语言中文本的从左到右，从上到下的渲染方式，以及传统HTML文档熟悉的文本布局。.

>  请注意，在非西方语言中，流向可能会改变。

大多数元素都处于 *normal flow*  中，元素离开  *normal flow*  的唯一方法是浮动、定位或成为弹性盒子或者成为网格布局元素。

请记住，本章中的讨论仅涵盖 *normal flow* 中的元素。



### Nonreplaced element 

内容即元素 这是其内容包含在文档中的元素。

例如：段落 （p） 是非替换元素，因为它的文本内容位于元素本身内

### Replaced element

占位符元素，会被渲染成其他内容

例如：*img*标签，只是简单的 指向 一个图像文件，然后在图片文件被找到时插入文档流中,大多数表单元素也是替换元素





### Root element

文档的根元素，在HTML文档中是 *html*，在*xml*中是任何元素

### Block box 

这是一个框，由元素（如paragraph(段落)、heading(标题)或 div）生成

1. 这些元素在 *normal flow* 中  在它本身前面、后面产生新行，这使得 *normal flow* 中 的块盒一个接一个地垂直堆叠。
2. 任何元素可以 通过声明 *display: block* 使之产生 *block box*
3. 支持全部的样式
4. 如果没有设置宽度，默认的宽度为父级宽度100%
5. 盒子占据一行、即使设置了宽度

### Inline box

这是 *strong* 或 *span* 等元素生成的框。

1. 不产生换行
2. Any element can be made to generate an inline box by declaring. 
3. 任何元素都可以通过声明  *display: inline* 来生成
4. 内联元素只能容纳文本或者其他内联元素
5. 如果包含了块元素，则块元素会将该内联元素分割成好几部分
6. 宽高由内容决定
7. 代码换行，盒子之间会产生间距
8. 子元素是内联元素，父元素可以用text-align属性设置子元素水平对齐方式

#### 内联元素的间隙问题

**内联元素之间有空白区域**

空白区域的形成是因为`<span>`之间有回车，在html中，空格、制表符、回车都属于空白符，多个空白符都会视为一个空格，

空格的大小由父级`<div>`的font-size决定。
注意：只有内联(内联块)与内联(内联块)之间的空白符才会形成一个空格，文本元素(除空白符)也是属于内联元素

**解决办法**

* 给`<div>`设置`font-size: 0;`，在`<span>`上把`font-size`设置回去
* 将空白符注释掉
* 把span排列在同一行，并紧贴在一起
* 使用浮动`float`



### Inline-block

这是一个在内部类似于 block box ，但在外部充当内联框。

它的作用类似于替换的元素，但并不完全相同。

想象一下，拿起一个div并将其粘贴到一行文本中，就好像它是内联图像一样，您就明白了。

还有几种其他类型的盒子，例如表格单元格盒子，但由于各种原因，它们不会在本书中介绍 - 其中最重要的是它们的复杂性需要单独开一本书来讲



## The Containing Block

包含块 很重要，需要重点讲

Every element’s box is laid out with respect to its containing block;

每个元素的盒子都相对于其包含块进行布局

以非常真实的方式（ in a very real way,），包含块是盒的"布局上下文"。

CSS 定义了一系列用于确定盒的包含块的规则

我们将只介绍与本书中涵盖的概念相关的规则，以保持我们的重点。

```
 For an element in the normal, Western-style flow of text, the containing block forms from the content edge of the nearest ancestor that generated a list item or block box, which includes all table-related boxes (e.g., those generated by table cells)
```

对于普通西式文本流中的元素，包含块从生成列表项或块框的最近祖先的内容边缘形成，其中包括所有与表相关的框

```
This is a paragraph.
```

* 在这个非常简单的标记中，p 元素的块框的包含块是 div 元素的块框，因为这是最接近的祖先元素框，它是块或列表项（在本例中，它是一个块框）。

* 同样，div的包含块是 body。因此，p 的布局依赖于 div 的布局，而 div 又依赖于 body 元素的布局。
* 在此之上，body 元素的布局取决于 html 元素的布局，html元素框创建了所谓的初始包含块（initial containing block）。
* html的独特之处在于，视口（屏幕媒体中的浏览器窗口或打印媒体中页面的可打印区域）决定了其尺寸，而不是根元素内容的大小。这是一个微妙的区别，通常不是一个非常重要的区别，但它确实存在。







## Altering Element Display

### DISPLAY

**Values**

```
[ <display-outside> ǁ <display-inside> ] | <display-listitem> | <displayinternal> | <display-box> | <display-legacy>
```

**Initial value** 

inline

**Applies to All** 

elements

**Computed value** 

As specified

**Inherited**

No

**Animatable** 

No

**Definitions**

`<display-outside>`

*block | inline | run-in*

`<display-inside>`

*flow | flow-root | table | flex | grid | ruby* 

`<display-listitem>`

*list-item && `<display-outside>` ? && [ flow | flow-root ]?* 

`<display-internal>`

*table-row-group | table-header-group | table-footer-group | table-row | table- cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container*

`<display-box>`

*contents | none* 

`<display-legacy>`

*inline-block | inline-list-item | inline-table | inline-flex | inline-grid*



我们将忽略与  *ruby- and table-related*相 关的值，因为它们对于本章来说太复杂了，我们也会忽略值 *list-item* 项，因为它与块框非常相似。我们已经花了相当多的时间来讨论块和内联框，但在我们查看内联块之前，让我们花点时间讨论一下 如何通过更改元素的显示角色 来改变布局。





### Changing Roles

在设置文档样式时，能够更改元素生成的框的类型非常方便。例如，假设导航中有一系列链接，我们希望将其布局为垂直侧边栏：

```
[WidgetCo Home](index.html) [Products](products.html) [Services](services.html) [Widgety Fun!](fun.html) [Support](support.html) [About Us](about.html) [Contact](contact.html)
```

We could put all the links into table cells, or wrap each one in its own nav—or we could just make them all block-level elements, like this: nav a {display: block;} 

This will make every a element within the navigation nav a block-level element.

Changing display roles can be useful in cases where you want non-CSS browsers to get the navigation links as inline elements but to lay out the same links as block-level elements. 

如果希望非 CSS 浏览器将导航链接作为内联元素获取，但将链接布局为块级元素，则更改显示角色可能很有用。将链接作为块使用时，您可以像使用 div 或 p 元素一样设置它们的样式，其优点是整个元素框将成为链接的一部分。因此，如果用户的鼠标指针悬停在元素框中的任意位置，她就可以单击该链接。

您可能还想获取元素并使其内联。假设我们有一个无序的名称列表

```html
<ul id="rollcall">
    <li>Bob C.</li>
    <li>Marcio G.</li>
    <li>Eric M.</li>
    <li>Kat M.</li>
    <li>Tristan N.</li>
    <li>Arun R.</li>
    <li>Doron R.</li>
    <li>Susie W.</li>
</ul>
```

给定此标记，假设我们要将这些名称制作成一系列内联名称，并在它们之间（以及列表的每一端）使用竖线。执行此操作的唯一方法是更改其显示角色

```css
#rollcall li 
	{display: inline; border-right: 1px solid; padding: 0 0.33em;}
#rollcall li:first-child {border-left: 1px solid;}
```



你正在更改元素的显示角色，而不是更改其固有性质（ inherent nature）。

换言之，使段落生成内联框不会将该段落转换为内联元素。

例如，在 HTML 中，某些元素是块元素，而其他元素是内联的。（还有一些是"流动"元素，但我们现在先忽略它们）。

内联元素可以是块元素的后代，但反之通常不行。

虽然 *span* 可以放在段落内，但 span 不能环绕 *paragraph*。  无论您如何设置相关元素的样式，这都适用。

请考虑以下标记：

```html
<span style="display: block;">
<p style="display: inline;">this is wrong!</p>
</span>
```

这个标记不合法，因为块元素 （p） 嵌套在内联元素 （span） 

The changing of display roles does nothing to change this.

更改显示角色不会改变这一点。

display 之所以有它的名字，是因为它会影响元素的显示方式，而不是因为它改变了元素的类型

话虽如此，让我们深入了解不同类型框的详细信息：块框，内联框，内联块框和列表项框（*block boxes, inline boxes, inline-block boxes, and list-item boxes*）



### Block Boxes

> 块框



块框的行为有时是可预测的，有时是令人惊讶的。

沿水平轴和垂直轴放置块框的处理方式不同，

例如。为了充分了解块框的处理方式，您必须清楚地了解许多边界和区域。完整盒模型示意图如下

![image-20220308004504113](..\..\images\complete_box_model.png)

​	默认情况下，块框的宽度定义为从左内边到右内边的距离，高度是从内顶到内底的距离。这两个属性都可以应用于生成块框的元素。我们也可以使用属性来改变这些属性的处理方式。

#### BOX-SIZING

**Values**

*content-box | padding-box | border-box*

**Initial value**

*content-box*

**Applies**

*to All elements that accept width or height values*

**Computed value**

As specified

**Inherited**

No

**Animatable** 

No

 此属性是更改宽度和高度值实际执行的操作的方式。

* 如果您声明宽度：400px并且没有声明为 *box-sizing*，则元素的内容框就是400像素宽;任何填充，边框等都将添加到其中使其实际大小大于400

* 另一方面，如果您声明了  *box-sizing*：*border-box*，则元素框将从左外边框边缘到右外边框边缘为400像素;任何边框或填充都将放置在该距离内，从而缩小内容区域的宽度。

我们在这里谈论 *box-size* 属性，因为如前所述，它适用于"接受宽度或高度值的所有元素。

这通常是生成块框的元素，尽管它也适用于替换的内联元素（如图像）以及内联块框。



各种宽度、高度、填充和边距都组合在一起，以确定文档的布局方式。在大多数情况下，文档的高度和宽度由浏览器自动确定，基于可用的显示区域以及其他因素。使用 CSS，您可以断言对元素大小和显示方式的更直接的控制





### Horizontal Formatting

水平格式通常比您想象的要复杂得多。部分复杂性与框大小的默认行为有关。

使用默认值 *content-box* 时，宽度指定的是 内容区的宽度，而不是整个可见元素框

**可视区**

不包括边框的以外的区域，包括 *content area+padding*

**整体区域**

可视区+外边距

**example1**

```
<p style="width: 200px;">wideness?</p>
```

* 可视区的宽度是200px
* 整体区域的宽度是 200px

**example2**

```
<p style="width: 200px; padding: 10px; margin: 20px;">wideness?</p>
```

* 可视区的宽度是 220px
* 整体区域的宽度是 260px

**example3**

如果改变example2的 *border-box:box-sizing* 

* 则可视区的内容始终为200px
* 内容宽度为180px
* 整体区域宽度为 260px

有一个恒定的规则：

**在正常流中， 块框的 水平分量的总和始终等于 包含块的宽度**

```html
<head>
	<style>
        div p {
            margin:1em;
        }
        div{
            width:30em;
        }
    </style>
</head>
<div>
    <p>1</p>
    <p>2</p>
</div>
```

### Horizontal Properties

水平格式化的七个属性是： *margin-left, border-left, padding-left, width, padding-right, border-right, and margin-right.* 



这些属性与块框的水平布局相关，如图 7-9 所示。这七个属性的值必须加起来等于元素的包含块的宽度，这通常是块元素父元素的宽度值（因为块级元素几乎总是具有父级的块级元素）。在这七个属性中，只有三个可以设置为自动：**元素内容的宽度以及左右边距**。**其余属性必须设置为特定值或默认为零的宽度**。下图显示了盒子的哪些部分可以采用 auto 值，哪些部分不能。

![image-20220308203310216](..\..\images\horizonal_auto_properties.png)

width 必须设置为 auto 或某种类型的非负值。

在水平格式中使用 auto 时，可能会出现不同的效果



### Using auto

#### 0个atuo

在CSS术语中 称之为 ：*overconstrained*

*margin-right*会强制成为 *auto*



#### 一个auto

如果 *width* 、*margin-left*、*margin-right* 三者有一个是*auto* 其他是精确值 那么auto会自适应 使之 等于 包含快的宽度

#### margin二个auto

如果*margin* 属性都是 *auto*  width是指定宽度。则 左右两个 会平分 宽度

#### 一个margin auto一个 内容区auto

则 margin auto那个 会被设置成 0。内容区宽度会尽可能大

#### 三个都是auto

默认的表现形式，如果没有指定，则全部是auto

此时 外边距会全部归0，内容区宽度尽可能大

### Negative Margins



可以为边距设置负值。设置负边距可能会导致一些有趣的效果。请记住，七个水平属性的总和始终等于父元素的宽度。只要所有属性都为零或更大，元素就永远不能大于其父级的内容区域

如果七个属性和 大于了 包含块的宽度 则 调整 *margin-right* 甚至为负值

### Percentages

百分比跟 指定宽度值没什么区别

边界不能接受百分比值，只能接受长度值。



### Replaced Elements

到目前为止，我们一直在处理正常文本流中非替换块框的水平格式。

块级替换元素更易于管理，适用于 非替换块 提供的所有规则都成立，但有一个例外：

* *width* 为 *auto* 时，则元素的宽度是内容的固有宽度。
* 以下示例中的图像宽度为 20 像素，因为这是原始图像的宽度：

```html
<img src="smile.svg" style="display: block; width: auto; margin: 0;">

```

可以手动指定 宽度值

```html
<img src="smile.svg" style="display: block; width: 25px; margin: 0;">
<img src="smile.svg" style="display: block; width: 50px; margin: 0;">
<img src="smile.svg" style="display: block; width: 100px; margin: 0;">
```



请注意，元素的高度也会增加

当替换元素的宽度从其固有宽度更改时，高度值将缩放以匹配，除非高度其自身 已设置为显式值

反之亦然：如果设置了高度，但宽度保留为自动，则宽度将按比例缩放到高度的变化中。

### Vertical Formatting

元素的内容决定了 元素的默认宽度

内容的宽度也会影响高度



例如，段落越窄，它必须越高才能包含其中的所有内联内容。

在CSS中，可以在任何块级元素上设置显式高度。如果这样做，则结果行为取决于其他几个因素。

假定指定的高度大于显示内容所需的高度：

```
<p style="height: 10em;">
```

在这种情况下，额外的高度具有类似于额外padding 的视觉效果



但假设高度小于显示内容所需的高度

```html
<p style="height: 3.33em;">
```



浏览器应该提供一种在不增加元素框高度的情况下查看所有内容的方法。

如果元素的内容高于其框的高度，则用户代理的实际行为将取决于 *overflow*属性





在 CSS1 下，如果元素不是替换的元素（如图像），则用户代理可以忽略除 auto 以外的任何高度值。

在 CSS2 及更高版本中，不能忽略高度值，除非在涉及特定百分比值的情况下。

.我们稍后会讨论这个问题。与宽度一样，默认情况下，高度定义内容区域的高度，而不是可见元素框的高度。元素框顶部或底部的任何填充、边框或边距都将添加到高度值中，除非 *box-sizing* 的值不是 *content-box*





### Vertical Properties

和水平格式化属性一样，垂直格式化属性也有同样的属性: *margin-top, border-top, padding-top, height, padding-bottom, borderbottom, and margin-bottom*. 

这些属性的值的总和 必须等于 块框包含快的 高度

这通常是块元素的 父元素（因为块级元素最近的 父级元素总是  块级元素）

只有 三个属性能被设置为 *auto*:  the height of the element, and the top and bottom margins. 

If border-style has been set, then the thickness of the borders is set to be the vaguely defined value medium. 



有趣的是，如果将正常流中的 将上边距或下边距设置为 *auto*，则它们都会自动计算为 0。

这也意味着，如果将元素的上边距和下边距设置为 *auto*，则它们实际上会重置为 0 并从元素框中删除。

### Percentage Heights

您已经了解了如何处理高度的长度值，因此让我们花点时间讨论一下百分比。如果正常流块框的高度设置为百分比值，则该值被设置为 块框包含块的高度的百分比。给定以下标记，生成的段落将是 3 em 高

```
<div style="height: 6em;">
<p style="height: 50%;">Half as tall</p>
</div>
```

由于将上边距和下边距设置为 *auto* 会使它们具有零高度，因此在这种特殊情况下，**垂直居中元素的唯一方法是将它们都设置为 25%**，即使这样，框也会居中，而不是其中的内容。

但是，如果未显式声明包含块的高度，则百分比高度将重置为 *auto*。

如果我们更改了前面的示例，使 div 的高度是自动的，则该段落现在将与 div 本身一样高：

```html
<div style="height: auto;">
<p style="height: 50%;">NOT half as tall; height reset to auto</p>
</div>
```

在我们继续前进之前，仔细看下 half-as-tall段落 ，它不是垂直居中的。因为 包含块的高度 是 6em 段落高度是3em 存在 上下 1em的*margin* 所以它的整体 框的高度是 *5em* 这意味着 还有  在段落可视区 到 div底部 还有 2em的 空白 

### Auto Heights

**块级子元素外边距合并**

在最简单的情况下，具有高度的正常流动块框："auto" 被呈现得刚好足够高，以包含其内联内容（包括文本）的行框。

如果  *auto-height,*、正常流的块框只有块级子级，则其默认高度将是从最顶层块级子级外边框边缘的顶部到最底部子级的外底边界边缘的底部的距离。因此，子元素的边距将"突出"包含它们的元素。

但是，如果块级元素具有顶部或底部*padding*，或者具有顶部或底部边框，则其高度将是其最上层子元素的上边距边缘的顶部与其最底部子元素的外下边距边缘的距离：

```html
<div style="height: auto;
background: silver;">
<p style="margin-top: 2em; margin-bottom: 2em;">A paragraph!</p>
</div>
<div style="height: auto; border-top: 1px solid; border-bottom: 1px solid;
background: silver;">
<p style="margin-top: 2em; margin-bottom: 2em;">Another paragraph!</p>
</div>
```

If we changed the borders in the previous example to padding, the effect on the height of the div would be the same: it would still enclose the paragraph’s margins within it

如果我们将上一示例中的边框更改为填充，则对 div 高度的影响将是相同的：它仍将段落的边距包含在其中



# 块布局

## **水平格式化**

**水平格式化七大属性**

水平格式化的“7大属性”是：`margin-left`、`border-left`, `padding-left`、`width`、 `padding-right`、`border-right`和`margin-right`

这7个属性的值加在一起**必须是元素包含块的宽度**，这往往是块元素的父元素的width 值（因为块级元素的父元素几乎都是块级元素。

**三大属性使用auto**

* 只有**width**、**margin-left**或**margin-right**值可以设置为auto，而余下两个属性指定为特定的值，那么设置为auto的属性会确定所需的长度，从而使元素框的宽度等于父元素的width
* auto使用规则表
  * 固定值 的优先级 > auto
  * 都为固定值时 ,  margin-right 最小优先级
  * width的auto总是把自己撑到最大,  且优先级大于 > lr的auto

* 如果七大属性的值 大于了父元素的宽度 





## **垂直格式化**

**垂直格式化七大属性**

`margin-top`、`border-top`, `padding-top`、`height`、 `padding-bottmon`、`border-bottmon`和`margin-bottom`



* 没有显示的申明 `包含块` (父元素)的 *height*  那么 子元素的百分数高度 会被重置为*auto*
* 使子元素 垂直居中的唯一方式是 使 上下外边距 25%

* 默认情况下, 上下外边距 *height* 均为auto, 且 元素的高度为 内容的高度

**合并垂直外边距**

* 邻块元素垂直方向上的外边距会合并,  取其中的最大的一个
* **因为外边距的目的是为了防止 不让元素间的边框 相接触, 而外边距是可以重合的**

* 负的外边距会把元素拉近



# 行布局

## **基本术语**

**匿名文本**

HTML中的不含标签的文本内容

**em框**(字符框)

字体定义的大小

**内容区**

元素中各个字符的EM框构成的框

**在替换元素中, 内容区就是 元素的固有高度, 加上 内外边距,边框等**

**行间距**

(*half-leading*) *font-size* 和*line-height* 值只差 除以2

**行内框**

内容区的高度 + 行间距 的高度  = 行高 *line-heigh*

**行框**

该行中出现的行 的最高点 和最低点的 最小框





## 行为定义

* 内容区类似于一个块级元素的 内容框
* 行内元素的背景 应用于 内容区+ 内边距
* 行内元素的边框 要包围内容区及内边距
* 非替换元素的内边距,边框,外边距 不会影响行内框的高度









### 块状元素与内联（行内）元素的嵌套规则

**什么是嵌套规则**

如果不按照HTML规则书写代码时，浏览器就不会正确解析，会将**不符合嵌套规则的节点放到目标节点的下面**，或者变成纯文本HTML存在许多种类型的标签，有的标签下面只允许特定的标签存在，这就是HTML嵌套规则。



**具体规则**

* 内联元素不可包含块元素，只能包含内联元素，块状元素没有这些限制
* 有几个特殊块级元素只能包含内联元素，不能包含块级元素。这几个特殊标签是 `h1~h6、p、dt`
* *li* 内可包含 div 标签
* 块级元素与块级元素并列、内联元素与内联元素并列









