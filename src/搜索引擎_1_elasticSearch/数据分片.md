

# 分片路由

当索引一个文档的时候，文档会被存储到一个主分片中

**Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？**

```
shard = hash(routing) % number_of_primary_shards
```



routing` 是一个可变值，默认是文档的 `_id，也可以设置成一个自定义的值

 `routing` 通过 hash 函数生成一个数字，然后这个数字再除以 `number_of_primary_shards` （主分片的数量）后得到 **余数** 



**主分片的数量不可变**

这就解释了为什么我们要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。



**自定义routing字段**

所有的文档 API（ `get` 、 `index` 、 `delete` 、 `bulk` 、 `update` 以及 `mget` ）都接受一个叫做 `routing` 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中。我们也会在[*扩容设计*](https://www.elastic.co/guide/cn/elasticsearch/guide/current/scale.html)这一章中详细讨论为什么会有这样一种需求。



# 主分片和副本分片如何交互

## **新建、索引和删除单个文档**

1. 客户端向 任意一个节点 发送新建、索引或者删除请求，该节点称为协调节点
2. 节点使用文档的 `_id` 确定文档属于哪个分片。请求会被转发到 该分片所处的节点
3. 该节点 在该文档的主分片上面执行请求。如果成功了，它将请求并行转发到该索引其他的副本分片上。一旦所有的副本分片都报告成功,将向协调节点报告成功，协调节点向客户端报告成功。

在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。



有一些可选的请求参数允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为Elasticsearch已经很快，但是为了完整起见，在这里阐述如下：

**consistency**

一致性：要求 大多数 副本分片处于活跃状态下才 会执行 写操作，是为了避免在发生网络分区故障（network partition）的时候进行_写_操作，进而导致数据不一致

规定数量：

```
int( (primary + number_of_replicas) / 2 ) + 1
```

**取值**

`one`:只要主分片状态 ok 就允许执行_写_操作

`all`:必须要主分片和所有副本分片的状态没问题才允许执行_写_操作

`quorum`: 即大多数的分片副本状态没问题就允许执行_写_操作。



**timeout**

如果没有足够的副本分片会发生什么？ Elasticsearch会等待，希望更多的分片出现。默认情况下，它最多等待1分钟。 如果你需要，你可以使用 `timeout` 参数 使它更早终止： `100` 100毫秒，`30s` 是30秒。

## 取回文档

1. 客户端向 任意节点 发送获取请求。（即协调节点）

2. 节点使用文档的 `_id` 来确定文档属于分片 `0` 。由于分片存在副本，轮询到其中一个节点的分片上

3、该节点 将文档返回给 协调节点 ，然后将文档返回给客户端。

在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。

在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。

 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。



## 局部更新文档

1. 客户端向 任意节点 发送更新请求。（即协调节点）
2. 它将请求转发到主分片所在的 处理节点 。
3. 处理节点 从主分片检索文档，修改 `_source` 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 `retry_on_conflict` 次后放弃。
4. 如果 处理节点 成功地更新文档，它将新版本的文档并行转发到 其他节点上的副本分片，重新建立索引。 一旦所有副本分片都返回成功，处理节点 向协调节点也返回成功，协调节点向客户端返回成功。

**基于文档的复制**

当主分片把更改转发到副本分片时， 它不会转发更新请求。

 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。

## 多文档模式

`mget` 和 `bulk` API 的模式类似于单文档模式。区别在于协调节点知道每个文档存在于哪个分片中。 它将整个多文档请求分解成 ***每个分片* 的多文档请求**，并且将这些请求并行转发到每个参与节点。

协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端

### **使用** `mget` **取回多个文档**

1. 客户端向 任意某个节点 发送 `mget` 请求。（即协调节点）
2. 协调节点 分析批量操作中每个请求的所位于的分片，并为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复，协调节点 构建响应并将其返回给客户端。

### **使用** `bulk` **修改多个文档**

1. 客户端向 任意某个节点 发送 `bulk` 请求。（即协调节点）
2. 协调节点分析批量操作中每个请求的所位于的分片，并将这些请求并行转发到每个包含主分片的节点主机
3. 主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。

`bulk` API 还可以在整个批量请求的最顶层使用 `consistency` 参数，以及在每个请求中的元数据中使用 `routing` 参数。



### 多文档模式中的换行符

为什么 `bulk` API 需要有换行符的有趣格式，而不是发送包装在 JSON 数组中的请求，例如 `mget` API？

在批量请求中引用的每个文档可能属于不同的主分片， 每个文档可能被分配给集群中的任何节点。这意味着批量请求 `bulk` 中的每个 *操作* 都需要被转发到正确节点上的正确分片。

如果单个请求被包装在 JSON 数组中，那就意味着我们需要执行以下操作：

- 将 JSON 解析为数组（包括文档数据，可以非常大）
- 查看每个请求以确定应该去哪个分片
- 为每个分片创建一个请求数组
- 将这些数组序列化为内部传输格式
- 将请求发送到每个分片



这是可行的，但需要大量的 RAM 来存储原本相同的数据的副本，并将创建更多的数据结构，Java虚拟机（JVM）将不得不花费时间进行垃圾回收



相反，Elasticsearch可以直接读取被网络缓冲区接收的原始数据。 它使用换行符字符来识别和解析小的 `action/metadata` 行来决定哪个分片应该处理每个请求。



这些原始请求会被直接转发到正确的分片。没有冗余的数据复制，没有浪费的数据结构。整个请求尽可能在最小的内存中处理。













