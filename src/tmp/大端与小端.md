## 大端模式和小端模式的区别

在C语言中除了8位的char型之外，还有16位的short型，32位的long型（要看具体的编译器），对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。

* 大小端说的是 数据的高字节 是否 放于 开始内存地址 



### 大端模式

字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中

### 小端模式

与大端存储模式相反，在小端存储模式中，低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节



例如，16位宽的数0x1234在小端模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：

| 内存地址 | 0x4000 | 0x4001 |
| -------- | ------ | ------ |
| 存放内容 | 0x34   | 0x12   |



而在大端模式CPU内存中的存放方式则为：

| 内存地址 | 0x4000 | 0x4001 |
| -------- | ------ | ------ |
| 存放内容 | 0x12   | 0x34   |



32位宽的数0x12345678在小端模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：

| 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
| -------- | ------ | ------ | ------ | ------ |
| 存放内容 | 0x78   | 0x56   | 0x34   | 0x12   |



而在大端模式CPU内存中的存放方式则为：

| 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
| -------- | ------ | ------ | ------ | ------ |
| 存放内容 | 0x12   | 0x34   | 0x56   | 0x78   |





Byte Endian是指字节在内存中的组织，所以也称它为Byte Ordering，或Byte Order。
   对于数据中跨越多个字节的对象， 我们必须为它建立这样的约定:

* 它的地址是多少?

* 它的字节在内存中是如何组织的?

  针对第一个问题，有这样的解释:

对于跨越多个字节的对象，一般它所占的字节都是连续的，它的地址等于它所占字节最低地址 (链表是个例外， 但链表的地址可看作链表头的地址)。

```
比如: int x， 它的地址为0×100。 那么它占据了内存中的Ox100， 0×101， 0×102， 0×103这四个字节（32位系统，所以int占用4个字节）。
```

上面只是内存字节组织的一种情况: 多字节对象在内存中的组织有一般有两种约定。 考虑一个W位的整数。
    它的各位表达如下:[Xw-1， Xw-2， ... ， X1， X0],它的
    MSB (Most Significant Byte， 最高有效字节)为 [Xw-1， Xw-2， ... Xw-8];
    LSB (Least Significant Byte， 最低有效字节)为 [X7，X6，...， X0]。