

# **数据库命名规范**

* 所有数据库对象名称必须使用小写字母并用下划线分割
* 所有数据库对象名称禁止使用mysql保留关键字
* 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符
* 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀
* 所有存储相同数据的列名和列类型必须一致

# **数据库设计规范**

* **所有表必须使用Innodb存储引擎**

  Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好

* **数据库和表的字符集统一使用UTF8**

  兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效

* **所有表和字段都需要添加注释**
* **尽量控制单表数据量的大小，建议控制在500万以内**
  
  * 500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题
* 可以用历史数据归档（应用于日志数据）,分库分表（应用于业务数据）等手段来控制数据量大小
  
* **谨慎使用MySQL分区表**

  * 分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据

* **尽量做到冷热数据分离，减小表的宽度**

  MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）

* **禁止在表中建立预留字段**

  预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定

* **禁止在数据库中存储图片，文件等大的二进制数据**

  通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息

* **禁止在线上做数据库压力测试**

* **禁止从开发环境，测试环境直接连接生成环境数据库**

  

# **数据库字段设计规范**

* **优先选择符合存储需要的最小的数据类型**
  
  * 空间
  * 索引
  
* IO
  
  例如 IP地址转换成整型
  
  ```
  inet_aton 把ip转为无符号整型(4-8位)
  inet_ntoa 把整型的ip转为地址
  ```
  
* 对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储

* **避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据**

  建议把BLOB或是TEXT列分离到单独的扩展表中

  Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。

  而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。

  如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。

  TEXT或BLOB类型只能使用前缀索引

  因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。

* **避免使用ENUM类型**

  1、修改ENUM值需要使用ALTER语句

  2、ENUM类型的ORDER BY操作效率低，需要额外操作

  3、禁止使用数值作为ENUM的枚举值

* **尽可能把所有列定义为NOT NULL**

  1、索引NULL列需要额外的空间来保存，所以要占用更多的空间；

  2、进行比较和计算时要对NULL值做特别的处理

* **使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间**

  经常会有人用字符串存储日期型的数据（不正确的做法）：

  缺点1：无法用日期函数进行计算和比较

  缺点2：用字符串存储日期要占用更多的空间

* **同财务相关的金额类数据必须使用decimal类型**

  1、非精准浮点：float,double

  2、精准浮点：decimal

* **尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型**

* 设计冗余列

* 禁用外键

* 分库分表

* 外键



# **索引设计规范**

* **限制每张表上的索引数量，建议单张表索引不超过5个**
  * 索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。
  * 因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。
* **每个Innodb表必须有个主键**
  * 不要使用更新频繁的列作为主键
  * 不适用多列主键（相当于联合索引） 
  * 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。
  * 主键建议使用自增ID值。



**如何选择索引列的顺序**

* **复合索引，哪个字段放在最前面，需要根据哪个字段经常出现在where条件中，哪个字段的选择性最好来判断的**,区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）
* 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；
* 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）





**优先考虑覆盖索引**

**覆盖索引：**就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引

覆盖索引的好处：

避免Innodb表进行索引的二次查询

Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，

如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。

**索引SET规范**

* **尽量避免使用外键约束**

  1、不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引；

  2、外键可用于保证数据的参照完整性，但建议在业务端实现；

  3、外键会影响父表和子表的写操作从而降低性能。

# **数据库SQL开发规范**

## **索引查询优化**

* **避免数据类型的隐式转换导致的索引失效**

* **充分利用表上已经存在的索引**

* **WHERE从句中禁止对列进行函数转换和计算**

* **对应同一列进行or判断时，使用in代替or**

* **like语句** 使用的是前缀索引

* **尽量避免在索引列上使用 MySQL 的内置函数或者表达式操作**

  ```sql
  -- 优化前
  select userId,loginTime from loginuser where Date_ADD(loginTime,Interval 7 DAY) >=now();
  
  -- 优化后
  explain  select userId,loginTime from loginuser where  loginTime >= Date_ADD(NOW(),INTERVAL - 7 DAY); 
  ```

* 避免使用 <> !=操作符

  反例：

  ```
  select age,name from user where age <>18; 
  ```

  正例：

  ```
  //可以考虑分开两条sql写
  select age,name  from user where age <18;
  select age,name  from user where age >18;
  ```

* 联合索引时,遵循最左匹配原则

* **使用覆盖索引**

  覆盖索引能够使得你的 SQL 语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。



## **减少查询数据量**

* 查询 SQL 尽量不要使用 select \*，而是 select 具体字段

  * 只取需要的字段，节省资源、减少网络开销。
  * select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询

* **如果知道查询结果只有一条或者只要最大/最小一条记录，建议用 limit 1**

  只要找到了对应的一条记录,就不会继续向下扫描了，效率将会大大提高。

  

## 书写规范

* **建议使用预编译语句进行数据库操作**
* **禁止使用不含字段列表的INSERT语句**

* **在明显不会有重复值时使用UNION ALL而不是UNION**
* **程序连接不同的数据库使用不同的账号，禁止跨库查询**
* **避免使用子查询，可以把子查询优化为join操作**
  
  * 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响；
  * 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；
  * 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。
* **减少同数据库的交互次数**
* **拆分复杂的大SQL为多个小SQL**

* 查询优化时, 考虑对 where, order by 建立索引

* **慎用 distinct 关键字**

* **如果数据量较大，优化你的修改/删除语句**

  分批插入或者分批删除

* **where 子句中考虑使用默认值代替 null**

* **不要有超过 5 个以上的表连接**

* **exist&in 的合理利用**

  小表驱动大表

* **尽量用 union all 替换 union**

# **数据库操作行为规范**

* **超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作。**

* **对于大表使用pt-online-schema-change修改表结构**

  ```
  对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。
  
  pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。
  
  把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。
  
  把原来一个DDL操作，分解成多个小的批次进行。
  ```

* **禁止为程序使用的账号赋予super权限**

  ```
  当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。
  ```

* **对于程序连接数据库账号，遵循权限最小原则**
