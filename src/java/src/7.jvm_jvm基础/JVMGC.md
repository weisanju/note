# 堆内存结构

> 堆是 Java 虚拟机进行垃圾回收的主要场所，其次要场所是方法区

> **在 JDK1.8 之后，堆的永久区取消了由元空间取代**

![20201025083104](https://i.loli.net/2020/10/25/VHxZERUfGOLWp2r.png)

# **JVM 如何判定一个对象是否要回收？**

> 判断一个对象是否应该被回收，主要是看其是否还有引用

## **引用计数法**

对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为 0 的对象。此算法最致命的是**无法处理循环引用**的问题。

## **可达性分析**

是通过一系列可以做为 root 的对象作为起始点，从这些节点开始向下搜索。当一个对象到 root 节点没有任何引用链接时，则证明此对象是可以被回收的。以下对象会被认为是 root 对象：

- 虚拟机栈 ( 栈帧的本地变量表 ) 中的引用对象。
- 方法区中类静态属性的引用的对象,常量引用的对象。
- 被启动类（bootstrap 加载器）加载的类和创建的对象
- 本地方法栈中**JNI**引用的对象。(native 方法)

**一句话总结**： 只要你的对象被**方法的局部变量、类的静态变量**给引用了，就不会回收他们。

# **JVM 垃圾回收算法有哪些**

> HotSpot 虚拟机采用了**可达性分析**来进行内存回收，常见的回收算法有**标记-清除算法，复制算法和标记整理算法。**

## 标记-清除算法(Mark-Sweep)

1. 从引用根节点开始标记所有被引用的对象，

2. 遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。

## 复制算法

复制算法把内存空间划为两个相等的区域，每次只使用其中一个区域

[复制算法](JVM复制算法.md)

## 标记-整理算法

标记-整理算法结合了**“标记-清除”和“复制”**两个算法的优点。也是分两阶段，

1. 从根节点开始标记所有被引用对象，

2. 遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。

# 垃圾收集器

JVM 中的垃圾收集器主要包括 7 种，即**Serial，Serial Old，ParNew，Parallel Scavenge，Parallel Old 以及 CMS，G1 收集器**
![20201025083626](https://i.loli.net/2020/10/25/uTM4G1b2mVUNKRH.png)

## Serial

- 是否需要 STW : 是
- 单线程/多线程: 单
- 算法: 未知
- 作用区域: 新生代

## Serial Old

- 是否需要 STW : 是
- 单线程/多线程: 单
- 算法: 未知
- 作用区域: 老年代

**当 CMS 并发收集发生 Concurrent Mode Failure 时使用。**

## ParNew 收集器

> Serial 收集器的**多线程**版本

- 是否需要 STW : 是

- 单线程/多线程: 新生代是并行的（多线程的）,老年代是串行的（单线程的）

- 作用区域: 新生代 ,老年代

- 算法: 新生代采用复制算法，老年代采用标记整理算法

- JVM 参数:

  `-XX：UseParNewGC`使用该收集器，

  `-XX：ParallelGCThreads` 可以限制线程数量

## **Parallel Scavenge**

> Paralle 收集器特点是更加关注吞吐量（吞吐量就是 cpu 用于运行用户代码的时间与 cpu 总消耗时间的比值）
>
> **自适应调节策略**是 Parallel Scavenge 收集器和 ParNew 的主要区别之一。

- 是否需要 STW : 是

- 单线程/多线程: **多线程**

- 作用区域: 新生代

- 算法: 复制算法

- JVM 参数:

  `-XX:MaxGCPauseMillis` 控制最大垃圾收集停顿时间

  `-XX:GCTimeRatio` 直接设置吞吐量大小

  `-XX:+UseAdaptiveSizePolicy` 可以打开 GC 自适应调节策略

## Parallel Old

> Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用 标记-整理算法。

- 是否需要 STW : 是
- 单线程/多线程: **多线程**
- 作用区域: 老年代
- 算法: 标记整理

## **CMS**

> Concurrent Mark Sweep,**并发标记清除**

> CMS 收集器是**一种以获取最短回收停顿时间为目标**的收集器

- 是否需要 STW : 很短的时间
- 单线程/多线程: **多线程**
- 作用区域: 老年代
- 算法: **标记清除**

- 步骤
  - **初始标记**：需要“Stop the World”，初始标记仅仅只是标记一下 GC Root 能直接关联到的对象，速度很快。
  - **并发标记**：是主要标记过程，这个标记过程是和用户线程并发执行的。
  - **重新标记**：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。
  - **并发清除**：和用户线程并发执行的，基于标记结果来清理对象。

![20201025091029](https://i.loli.net/2020/10/25/OA54YwmhG1eSXaI.png)

* 优点

  STW时间短

* 缺点
  * **对CPU资源非常敏感**与用户线程并行, 资源不足导致效率低
  * 产生**浮动垃圾**,  不可以在老年代内存不够用了才进行垃圾回收,必须提前进行垃圾收集
    * 由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了**“Floating Garbage”**，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，**并发收集器一般需要20%的预留空间**用于这些浮动垃圾。
    * **-XX:CMSInitiatingOccupancyFraction**的值来控制内存使用百分比。如果该值设置的太高，
    * 那么在CMS运行期间预留的内存可能无法满足程序所需，会出现**Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器**，会产生更长时间的停顿。
  * **标记-清除方式会产生内存碎片**
    * **-XX:UseCMSCompactAtFullCollection**来控制是否开启内存整理（无法并发，默认是开启的）。
    * **-XX:CMSFullGCsBeforeCompaction**用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。

## **G1**

> **Garbage-First**

G1收集器将新生代和老年代取消了，取而代之的是**将堆划分为若干个区域**，每个区域都可以根据需要扮演新生代的Eden和Survivor区或者老年代空间，仍然属于分代收集器，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。

通过**将JVM堆分为一个个的区域（region）**,G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次**根据回收时间来优先回收价值最大的region。**

**G1收集器的特点：**

- **并行与并发**：G1能充分利用多CPU，多核环境下的硬件优势，来缩短Stop the World，是并发的收集器。
- **分代收集**：G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。
- **空间整合**：G1从整体来看是基于标记-整理算法，从局部（两个Region）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。
- **可预测的停顿**：能够建立可以预测的停顿时间模型，预测停顿时间。

**和CMS收集器类似，G1收集器的垃圾回收工作也分为了四个阶段：**

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

其中，筛选回收阶段首先对各个Region的回收价值和成本进行计算，根据用户期望的GC停顿时间来制定回收计划。



# Java常用版本垃圾收集器

```cmd
java -XX:+PrintCommandLineFlags -version
```

jdk1.8默认的新生代垃圾收集器：Parallel Scavenge，老年代：Parallel Old

jdk1.9 默认垃圾收集器G1



