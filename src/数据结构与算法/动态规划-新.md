## 1. 动态规划概念





动态规划的本质不在于是递推或是递归，也不需要纠结是不是内存换时间。

动态规划 方法论 意在帮助我们快速找到解决问题的办法





如下图。我们在解决某些最优问题时可将解决问题的过程按照一定次序分为若干个互相联系的阶段（1, 2, ..., N），从而将一个大问题化成一系列子问题，然后逐个求解。


在每一个阶段都需要作出决策，从而使整个过程达到最优
各个阶段决策的选取**仅依赖当前状态**（这里的当前状态指的是当前阶段的输入状态），从而确定输出状态

当各个阶段决策确定后，就组成了一个决策序列，这个决策序列就决定了问题的最终解决方案。

这种把一个问题可看作是一个前后关联具有链状结构的多阶段过程就称为**多阶段决策过程**。

动态规划将一个大问题化成**一族互相联系、同类型的子问题**
既然是同类型，我们在逐个解决子问题的时候，就可以利用相同的决策，从而更容易的解决问题。

互相联系利用前面已经解决的子问题的最优化结果来依次进行计算接下来的子问题，当最后一个子问题得到最优解时，就是整个问题的最优解。

这里面包括两个关键点：
每一个阶段可能包括很多状态，前后阶段的状态通过决策联系在一起。

如果要利用前阶段子问题的结果解决现阶段的子问题，必须要能够建立前后阶段状态的转移关系，最好可以通过方程表示。用专业术语我们又叫做**”状态转移方程“**。

我们在衡量最优解的时候需要有一个指标函数，最优解就是让这个指标函数达到最优值，比如最大或者最小

如果我们可以将问题拆分成子问题，那么这个**指标函数也必须具有分离性**
，也就是必须能够利用子问题的最优递推的求出整体最优。当整体最优求解出以后，就可以知道各个子问题的最优解。



例如，平时购物找零钱时，为使找回的零钱的硬币数最少，不要求找零钱的所有方案，而是从最大面值的币种开始，按递减的顺序考虑各面额，先尽量用大面值的面额，当不足大面值时才去考虑下一个较小面值，这就是贪心算法


2. 

3. 题目1:找零钱问题

4. 题目2:最短路径算法

5. 总结三步

6. 找状态

7. 找状态转移方程

8. 编码

9. 优化

10. 最长递增子序列

11. 最长连续递增子序列

12. 0-1背包问题

13. 总结

14. 动态规划 本质

15. 降低问题的复杂度

16. 子问题 推导出 大问题

17. 技巧

18. 找状态

19. 此状态是否能 由子状态得到，或者说子状态对 父状态有没有帮助

20. code

21. 根据转移写出 递归式。因为递归式是最自然的 表达形式

22. 优化

23. 消除重叠子问题：加缓存 优化时间复杂度

24. 自顶向下->自底向上：改成迭代

25. 叠加状态 优化空间复杂度