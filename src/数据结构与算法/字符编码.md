# 字符编码

## ASCII

1. 一共128个字符的编码
2. 占七位的bit位,最前面的一位统一为0

## ISO-8859-1

1. 扩展的ASCII编码,对 1000 0000 ~ 1111 1111 这一段进行了编码,总共能表示256个字符
2. 但仍然无法表示中文

## GB2312

1. 是第一个汉字编码国家标准共收录汉字6763个，其中一级汉字3755个，二级汉字3008个

2. 同时，GB2312编码收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符

3. 编码原理

   1. 分为`94`个区,每个区对应`94`个码位则 `GB2312`的编码范围为 `0101~9494` (十进制)
      1. 01-09区 收录除汉字外的682个字符
      2. 10-15区为空白区，没有使用。
      3. 16-55区收录3755个一级汉字，按拼音排序。
      4. 56-87区收录3008个二级汉字，按部首/笔画排序。
      5. 88-94区为空白区，没有使用。
   2. 加上0xA0 即为 GB2312实际编码值 二进制编码范围为 `0xA1A1~0XFEFE`
   3. GB2312采用双字节编码, 高字节表示区位,低字节表示码位

4. example

   1. '李' 的区位码是3278 ,32区78位,  转换成 十六进制  0x204E, 加上0xA0 =  0xC0EE

5. 汉字码位与码点查询

   https://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php

   

## BIG5

1. BIG5采用双字节编码,高位字节使用了0x81-0xFE，低位字节使用了0x40-0x7E，及0xA1-0xFE

2. 是繁体中文字符集编码,共收录13060个中文字，其中有二字为重复编码，即“兀、兀”（A461及C94A)和“嗀、嗀”(DCD1及DDFC)

3. 具体分区

   ```
   8140-A0FE 保留给使用者自定义字符（造字区）
   A140-A3BF 标点符号、希腊字母及特殊符号。其中在A259-A261，收录了度量衡单位用字：兙兛兞兝兡兣嗧瓩糎。
   A3C0-A3FE 保留。此区没有开放作造字区用。
   A440-C67E 常用汉字，先按笔划再按部首排序。
   C6A1-F9DC 其它汉字。
   F9DD-F9FE 制表符。
   ```

## GBK

1. GBK编码扩展了GB2312，完全兼容GB2312编码,不兼容BIG5编码

2. 编码范围

   8140－FEFE，剔除xx7F码位，共23940个码位,

   共收录汉字和图形符号21886个，其中汉字（包括部首和构件）21003个，图形符号883个

## ANSI

1. 在winodws平台 对于英文文件是`ASCII`编码，对于简体中文文件是`GB2312`编码
2. 在繁体中文Windows操作系统中，ANSI编码代表Big5；
3. 在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码
4. 不同 ANSI 编码之间互不兼容

## Unicode

### Unicode简介

1. Unicode是一张表,规定了每个字符对应二进制的值

2. Unicode表包含了1114112个码点，即从000000（十六进制） - 10FFFF（十六进制)

3. Unicode将码空间划分为17个平面, 从 00-10(十六进制),最高位的一个字节,每个平面有65536个码点,即两个字节

   1. 基本多语言平面（Basic Multilingual Plane）码点从 0000~FFFF,包含了最常用的字符
      1. 其中从D800到DFFF之间的码位区段是永久保留不映射到字符的
   2. 其他平面称为辅助平面(Supplementary Planes)

4. Unicode只是一个符号集，只规定的字符所对应的码点，并没有指定如何存储

5. unicode码点表

   https://unicode-table.com/cn

6. 关于Unicode编码方案主要有两条主线：UCS和UTF。UTF主线由Unicode Consortium进行维护管理，UCS主线由ISO/IEC进行维护管理。

7. **注意，BMP里存在一种特殊区域: 代理区(Surrogate)。Unicode标准规定U+D800 - U+DFFF的值不对应于任何字符**。后面可以看到，UTF-16就巧妙地利用了这一段空白区域进行了编码的转换。









### UCS(Universal Character Set)

#### UCS-2

1. 定长二个字节编码, 0000~FFFF 对应的码点范围 对应第一个Unicode平面
2. 采用BOM(Byte Order Mark)机制，该机制作用如下：
   1. 确定字节流采用的是大端序还是小端序。
   2. 确定字节流的Unicode编码方案。

#### UCS-4

1. UCS-4是定长字节的，固定使用4个字节进行编码。也采用了BOM机制。

### UTF-8(Unicode Transformation Format)

1. UTF-8是一种变长编码方式，使用1-4个字节进行编码

2. 完全兼容ASCII

3. 编码规则

   1. 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码

   2. 对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

   3. unicode范围以及 对应UTF-8编码方式

      

      | Unicode范围(十六进制位数) | 十进制范围    | 二进制范围 | UTF-8编码方式                          | UTf-8实际可编码的位数 |
      | :------------------------ | ------------- | ---------- | -------------------------------------- | --------------------- |
      | 0000 0000 ~ 0000 007F     | 0~127         | 1-7        | 0xxx xxxx<br /> (ASCII编码范围)        | 7                     |
      | 0000 0080 ~ 0000 07FF     | 128~2047      | 7-11       | 110x xxxx 10xx xxxx                    | 11                    |
      | 0000 0800 ~ 0000 FFFF     | 2048~65535    | 11-16      | 1110 xxxx 10xx xxxx 10xx xxxx          | 16                    |
      | 0001 0000 ~ 0010 FFFF     | 65536~1114111 | 16~21      | 11110xxx 10xx xxxx 10xx xxxx 10xx xxxx | 21                    |

   4. Unicode规定从 0000~FFFF 为基本多语言平面,故 前三个字节为 BMP平面

4. 举例

   1. '我'的 Unicode码 **6211**(十六进制)
      1. 根据范围占三个字节
      2. `6211`的二进制为 `110 001000 010001`
      3. 将'我'二进制代码从低位到高位依次填入x中，不足的填入0
         1. UTF-8编码位:  `11100110 10001000 10010001`
         2. UTF-8编码的十六进制为 E6 88 91

### UTF-16

1. UTF-16使用2或4个字节编码
2. 1. -若Unicode码点在第一平面（BPM）(0x0000 ~ 0xFFFF)中，则使用2个字节进行编码。
   2. 若Unicode码点在其他平面（辅助平面）(0x01 0000~0x10 FFFF)，则使用4个字节进行编码。
      1. 首先减去 0x01 0000 得到二个字节 最大值为 0x 0F FFFF,共20位有效位数
      2. 取高十位 扩充成 二个字节, 高十位的取值 为 D800 ~ DBFF
      3. 取低十位 扩充成 二个字节,低十位的取值 为 DC00 ~ DFFF
      4. 组合四个字节即为UTF-16编码
   3. 识别大端 还是小端 be,le
      1. 在文件前加入FE FF 采用大端序(大端在前的顺序)
      2. 则在文件前加入FF FE 采用小端序(小端在前的顺序)
3. 举例

   1. '我' 字的Unicode码 **6211**(十六进制) 位于基本平面 所以取原值 `6211`
      1. unicode编码 `0x01 0001`
      2. 减去01 0000 , 得 0x 0  0001
      3. 高字节 :  0 + D800
      4. 低字节:   1 + DC00 = DC01
      5. UTF-16得编码为:`D800 DC01` (大端模式)
      6. 小端模式 `00D8 01DC`
4. Java String  UniCode采用 UTF16编码

### 字符编码的区别

#### UCS-2 与 UTF-16区别

​		UCS-2采用的两个字节进行编码。在0000到FFFF的码位范围内，它和UTF-16基本一致，为什么说基本一致，因为在UTF-16中从U+D800到U+DFFF的码位不对应于任何字符

　　UCS-2只能表示BMP内的码点（只采用2个字节）

而UTF-16可以表示辅助平面内的码点（采用4个字节）。

　　我们可以抽象的认为UTF-16可看成是UCS-2的父集。在没有辅助平面字符（surrogate code points）前，UTF-16与UCS-2所指的意思基本一致。

但当引入辅助平面字符后，想要表示辅助平面字符时，就只能用UTF-16编码了。

#### UCS -4与 UTF-16的区别

　　在BMP上，UTF-16采用2个字节表示，而在辅助平面上，UTF-16采用的是4个字节表示。对于UCS-4，不管在哪个平面都采用的是四个字节表示。

#### 为什么UTF-8编码不需要BOM机制

　　因为在UTF-8编码中，其自身已经带了控制信息，如1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx，其中1110就起到了控制作用，所以不需要额外的BOM机制。



### **emoji表情的unicode编码**

Unicode只是规定了 emoji 的码位和含义，以及用文字指导它们代表的表情长什么样，并没有规定它的具体样式

渲染的工作则由各个系统自己实现。如果用户的系统没有实现某个emoji表情的渲染，就会显示成一个空方框。

在MAC中，输入ctrl + cmd + 空格后在弹出的面板里添加unicode代码表就可以看见每个unicode码位对应的字符了。



从U+1F300开始，存放的这些小表情就是emoji表情。



​		可以发现简单的笑脸对应的是Unicode的一个码位，但一个蒸馏器对应了两个码位，一个金发男子表情竟然对应了五个码位。我们看到，一个emoji表情也是变长存储的，而且一个表情可占用多个码位组成。那么这些表情的渲染又有什么规则呢？

要解答这个问题，需要阅读unicode官方介绍[emoji表情的文档](https://www.unicode.org/reports/tr51/#Emoji_Properties_and_Data_Files)

```
text_presentation_selector := \x{FE0E}
```

U+FE0E的含义是，一个text_presentation_selector，大概意思是文本表示选择符。

```
text_presentation_sequence := emoji_character text_presentation_selector
```



这个定义表明，加上了这个U+FE0E修饰的emoji字符会构成一个文本表示序列

所以，这个text_presentation_selector U+FE0E是用来修饰前面的emoji表情,指定其展示方式的。

```javascript
emoji_presentation_selector := \x{FE0F}
emoji_presentation_sequence := emoji_character emoji_presentation_selector
```

例如这个蒸馏器表情就是由U+FE0F修饰U+2697产生的

由此，我们理解了U+FE0F的作用，相当于一个修饰符，在渲染文字时如果遇到了U+FE0F就和前面的字符组合一下，改成渲染成一个emoji表情的形式

这样就可以理解上面的蒸馏器为什么占用了二个Unicode码位了。本身这个表情就是由其他字符加上修饰符组合而成的。



```
emoji_modifier := \p{Emoji_Modifier}
emoji_modifier_base := \p{Emoji_Modifier_Base}
emoji_modifier_sequence := emoji_modifier_base emoji_modifier
```

在输入法中找到U+1F471号字符

再找到U+1F3FF号字符，单独输出

这次再将两个表情连在一起输出，结果变成了一个



类似还有其他的组合规则，如国旗，键盘等都有各自的组合规则，也是用具有不同属性的unicode字符组合而成。详情可翻阅文档查阅。



#### ZWJ

zero-width joiner，意思是零宽度连字符

占用码位U+200D，这个字符不是为emoji单独服务的

用于插入在某些语言的字符中，使左右的两个字符连在一起产生连字效果，合成单个人类可读的字符。



具体到emoji表情中，某些单个显示表情也会由多个独立的ZWJ连字合成得到。



可以看到，这个红发女子就是由U+1F469和U+1F9B0使用U+200D连字得到的。下面我们来输入看看这两个字符分别代表什么。

红发女子就是由U+1F469和U+1F9B0使用U+200D连字得到的

这表明，U+1F469代表的是一个女子，而U+1F9B0单个表情代表的是头发的颜色，利用U+200D组合到一起，就得到了红发女子这个表情。

## 参考链接

1. https://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php
2. https://www.cnblogs.com/leesf456/p/5317574.html
3. https://www.qqxiuzi.cn/bianma/zifuji.php
4. https://cloud.tencent.com/developer/article/1680413

