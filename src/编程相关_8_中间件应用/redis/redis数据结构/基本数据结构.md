# 五种基础数据结构

redis 的所有数据结构都以唯一的 key 字符串作为名称，通过唯一的 key 获取相对应的 value 数据。不同的数据类型的差异就在于 value 的结构不一样。

- string（字符串）
- list（列表）
- hash（字典）
- set（集合）
- zset（有序集合）



# string

string 是最简单的数据结构，其内部就是一个字符数组。string 是动态字符串，相当于 ArrayList，当字符串长度小于 1M 时扩容都是加倍现有的空间。当字符串长度大于 1M 时每次扩容只会增加 1M 的空间。字符串长度最大为 512M。

## 键值对操作

```sh
127.0.0.1:6379> set name codehole
OK
127.0.0.1:6379> get name
"codehole"
127.0.0.1:6379> exists name
(integer) 1
127.0.0.1:6379> del name
(integer) 1
127.0.0.1:6379> get name
(nil)
127.0.0.1:6379>
```

## 批量键值对操作

```sh
mset key value [key value ...]
mget key [key ...]
```

```sh
127.0.0.1:6379> set name1 codehole
OK
127.0.0.1:6379> set name2 holycoder
OK
127.0.0.1:6379> mget name1 name2 name3
1) "codehole"
2) "holycoder"
3) (nil)
127.0.0.1:6379> mset name1 boy name2 girl name3 unknown
OK
127.0.0.1:6379> mget name1 name2 name3
1) "boy"
2) "girl"
3) "unknown"
127.0.0.1:6379>
```

## 过期和 set 命令拓展

- expire：设置指定 key 的过期时间
- setex：添加 key 并设置过期时间
- setnx：如果key不存在添加，key存在则不添加。

## 计数

- incr key
- incrby key increment

如果 value 是整数，可以对其进行自增操作。注意：自增是有范围的，范围在 signed long 的最大值和最小值之间，超过返回会报错。



# list

* list 相当于 java 中的 LinkedList，由于是链表结构故新增和删除特别快，但是索引定位特别慢。redis 中的 list 是双向链表结构，支持前后遍历，当列表最后一个元素被删除时，该数据结构会被自动删除。
* redis 的 list 结构常用来做异步队列使用。将需要延后处理的任务序列化成字符串，放入 redis 的 list，另一个线程从这个列表中轮训数据进行处理。
* 使用 list 可以实现先进先出（队列）和后进先出（栈）的效果，添加命令有：`lpush`、`rpush`，区别在于取出命令的区别：`lpop`、`rpop`。
* lpop、rpop记忆：假设 list 元素都是从右边进来(rpush)，左边出是队列，对应命令是 lpop；右边出是栈，对应的命令是 rpop。

## **右进左出：队列**

- rpush key value [value ...] 从右边添加数据，相反的还有 lpush。
- llen key
- lpop key

## 右进右出：栈

- rpush key value [value ...]
- rlen key
- rpop key

## 慢操作

- lindex key index：相当于 Java 链表的 get(int index)，由于需要对链表进行遍历，性能随着 index 增大而变差。
- ltrim key start stop：修剪 start 和 end 区间之间的值，外边的去掉。
- lrange key start stop：获取索引范围内的值。
- 索引值可以为负数，-1 代表倒数第一个元素，-2 代表倒数第二个元素，这点和 Groovy 的 Range 对象很相似。

*example*

```shell
127.0.0.1:6379> rpush books python java golang
(integer) 3
127.0.0.1:6379> lindex books 1
"java"
127.0.0.1:6379> lrange books 0 -1
1) "python"
2) "java"
3) "golang"
127.0.0.1:6379> ltrim books 1 -1 # 去掉第一个元素
OK
127.0.0.1:6379> lrange books 0 -1 # 查看所有元素
1) "java"
2) "golang"
127.0.0.1:6379> ltrim books 1 0 # 区间范围长度为负数，会清空 list。
OK
127.0.0.1:6379> llen books
(integer) 0
127.0.0.1:6379>
```

## 快速列表

redis list 结构并不简单是一个 linkedList，而是一种称之为「快速链表quicklist」的结构。

在列表元素较少的情况下，会使用一块连续的内存存储，这个结构是 ziplist，即「压缩列表」。

它将所有的元素彼此紧挨着一起存储，分配的是一块连续的内存。

当数据量比较多的时候才会改成 quicklist，因为普通链表需要附加的指针空间太大，会浪费空间，还会加重内存的碎片化。

比如某普通链表存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。

所以 redis 将链表和 ziplist 结合起来组成了 quicklist。将多个 ziplist 使用双向指针串起来使用。



# hash

> hash 相当于 java 的 HashMap，value 是一个键值对。它是一个无序字典，最后一个元素移除后该结构会被删除。

hash 相当于 java 的 HashMap，value 是一个键值对。它是一个无序字典，最后一个元素移除后该结构会被删除。

适用场景：使用 string 时保存一个用户信息需要将整个对象序列化存入，当我们只需要某个属性却需要把整个对象取出，这样会浪费网络流量和时间。使用 hash 可以将用户信息分段存储，可以只取出部分数据。



## 基本操作

- hset key field value
- hget key field
- hgetall key
- hlen key
- hmset key field value [field value ...]
- hmget key field [field ...]

## **example**

```shell
127.0.0.1:6379> hset userList user1 zhangsan
(integer) 1
127.0.0.1:6379> hset userList user2 lisi
(integer) 1
127.0.0.1:6379> hset userList user3 wangwu
(integer) 1
127.0.0.1:6379> hgetall userList # 获取所有，key value 依次输出。
1) "user1"
2) "zhangsan"
3) "user2"
4) "lisi"
5) "user3"
6) "wangwu"
127.0.0.1:6379> hlen userList
(integer) 3
127.0.0.1:6379> hget userList user2
"lisi"
127.0.0.1:6379> hset userList user2 lisa # 修改值返回0
(integer) 0
127.0.0.1:6379> hget userList user2
"lisa"
127.0.0.1:6379> hmset userList user4 Harry user5 Jessica # 多个设值
OK
127.0.0.1:6379> hgetall userList
 1) "user1"
 2) "zhangsan"
 3) "user2"
 4) "lisa"
 5) "user3"
 6) "wangwu"
 7) "user4"
 8) "Harry"
 9) "user5"
10) "Jessica"
127.0.0.1:6379> hmget userList user4 user5 user6 # 多个取值
1) "Harry"
2) "Jessica"
3) (nil)
```

## 计数

**hash 的 field 也可以进行计数，用法和 incrby 一样。**

- hincrby key field increment

```
127.0.0.1:6379> hset user-Harry age 21
(integer) 1
127.0.0.1:6379> hget user-Harry age
"21"
127.0.0.1:6379> hincrby user-Harry age 1 # 年龄 +1
(integer) 22
127.0.0.1:6379> hget user-Harry age
"22"
```

# set

set 相当于 java 的 HashSet，以键值对存储，无序，唯一。

- sadd key member [member ...]
- smembers key
- sismember key member
- scard key
- spop key [count]

```shell
127.0.0.1:6379> sadd books python
(integer) 1
127.0.0.1:6379> sadd books python # 重复添加不会生效
(integer) 0
127.0.0.1:6379> sadd books java golang
(integer) 2
127.0.0.1:6379> smembers books # 查看所有成员
1) "python"
2) "java"
3) "golang"
127.0.0.1:6379> sismember books java # 是否是一个成员
(integer) 1
127.0.0.1:6379> sismember books rust
(integer) 0
127.0.0.1:6379> scard books # 相当于 count()
(integer) 3
127.0.0.1:6379> spop books # 弹出一个
"python"
127.0.0.1:6379> smembers books
1) "java"
2) "golang"
```

# zset

## 介绍

有序列表，类似于 Sorted 和 HashMap 的结合体。

一方面它是一个 set，保证元素的唯一性；另一方面它可以为每个 value 赋予一个 score 作为这个 value 的排序权重。

其内部实现用的是一种叫做「跳跃链表」的数据结构。

适用场景：

1. 存储粉丝列表，value 是粉丝的用户Id，score 是关注时间。我们可以以此对粉丝列表按关注时间排序；
2. 存储学生成绩，value 是学生的ID，score 是他的成绩，以此对成绩分组进行排序。

## 常用命令

- **zadd key score member** [score member ...]：添加一个或多个成员
- **zrange key start stop** [WITHSCORES]：查看成员区间，WITHSCORES 表示显示成绩。
- **zrevrange key start stop** [WITHSCORES]：反向查看成员区间
- **zcard key**：成员个数
- **zscore key member**：查看成员排序权重
- **zrank key member**：查看指定成员的排名
- **zrangebyscore key min max** [WITHSCORES] [LIMIT offset count]：以成绩排名显示
- **zrem key member** [member ...]：移除指定成员

# 过期时间

redis 的所有数据结构都可以设置过期时间（单位 s），时间到了，redis 会自动删除相应的对象。

1. 过期是以对象为单位的，即一个 key 是一个对象。比如一个 Hash 结构的过期是整个 key 的过期而不是某个子 key 的过期。
2. 如果一个字符串设置了过期时间，然后调用 set 方法设置了它，它的过期时间会消失。

```shell
127.0.0.1:6379> set codehole yoyo
OK
127.0.0.1:6379> expire codehole 600
(integer) 1
127.0.0.1:6379> ttl codehole
(integer) 596
127.0.0.1:6379> set codehole yoyo
OK
127.0.0.1:6379> ttl codehole
(integer) -1
127.0.0.1:6379>
```